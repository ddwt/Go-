##Go学习笔记-基础法语（一）
###1. 变量
+ 变量声明
> 引入关键字var，类型信息放在变量名后
> 不用分号结尾
`var v1 int`
`var v2 string`
`var v3 [10]int`
`var v4 []int`
`var v5 *int`
`var v6 map[string]int`
`var v7 func(a int ) int`
+ 变量初始化
> var v1 int = 10
> var v2 = 10
> v3 := 10【前提是v3没有被声明过】
+ 变量赋值
>特殊 多重赋值 i, j = j, i【交换i, j】
+ 匿名变量
> 在返回多个值时避免获得无用值而定义变量
> \_, _, nickName := GetName()
###2. 常量
+ 字面常量
>多种选择下，是无类型的，可以赋值给任何一种类型变量
+ 常量定义
>常量可以限定数据类型，但不是必须的
>编译期行为，右值不可以是运行期得结果的表达式
+ 预定义常量
>true
>false
>iota: 比较特殊，可以认为是一个可被编译器修改的常量，在每一个const关键字出现时被重置为0，然后在下一个const 出现之前，每出现一次iota,其代表的数字会自动+1
+ 枚举
> 枚举指一系列相关的常量
### 3.数据类型
+ 布尔、整型、浮点、复数、字符串、字符类型、错误类型【基础类型】
+ 指针、数组、切片、字典、通道、结构体、接口【复杂类型】
+ 布尔类型
>布尔类型不能接受其他类型的赋值，不支持自动或强制的类型转换
+ 整型
> int和int32在GO语言里认为是不同的类型，编译器不会自动做类型转换
> 取反是 ^x
+ 浮点型
> float32等价于C中的float
> float64等价于C中的double
> 自动推导是64的
> 比较大小，用math.Fdim(f1, f2) < p 【p是用户自定义精度】
+ 字符串
> 常用操作：
> x + y 连接
> len(str) 取长度
> str[i] 取字符
+ 字符类型【2个】
>  byte, UTF-8
>  rune，unicode
+ 数组
> 在GO中，数组是值类型，传参会复制
+ 数组切片
>+  数组切片可以抽象为以下3个变量
> 1. 一个纸箱原生数组的指针
> 2. 数组切片中的元素个数
> 3. 数组切片已分配的存储空间
> 
>+ 创建数组切片
> 方法有两种，基于数组【或数组切片】和直接创建
>+ 操作数组的所有方法都适用于数组切片
>【range有两个返回值，第一个是索引，第二个是元素的值】
>+ 动态增减元素
>不同于vector，是从开始就开大空间，达到空间换时间
>+  内容复制
>如果大小不一样，按小的来
+ map
>Go中使用map不需要引入任何库
>map是一堆键值对的未排序集合，底层是哈希表
>+ 1.变量声明和创建
>var myMap map[key] value
>myMap = make(map[key] value )  
>+ 2. 元素删除
>delete(myMap, "1234")
>如果这个键不存在，无副作用，如果map变量是nil，程序抛出异常
>+ 3.元素查找【3步】
>声明并初始化一个变量为空
>试图从map中获取相应键的值到该变量中
>判断该变量是否依旧为空，如果为空则表示map中没有包含该变量
### 3. 流程控制语句 
+ 条件判断语句
>+ if...else..注意：
>条件语句不需要使用括号扩起来
>无论语句体内有几条语句，花括号都是必须存在的
>if 后添加初始化变量需要用；间隔
>在有返回值的函数中，不允许将 最后的 return语句放到if ... else 结构中
>+ switch..case语句
>自带break功能，若要向下进行需要加 fallthrough
+ 循环语句
>Go只支持for语句，while和do-while都不行
>高级的break，可以根据标签中断循环
### 4. 函数
+ 4.1 基本组成及定义
> 关键字func、函数名、参数列表、返回值、函数体和返回语句
> func Add(a int, b int) (ret int, err error)
> 【多参数返回，类型放到后边】
+ 4.2 函数调用【特别注意，大写字母开头的函数才可以被别的包调用】
> 先导入函数所在包怕,然后通过包调用函数
> import "mymath"
> c := mymath.Add(1, 2)
+ 4.3 不定参数
> + func Func(args ...type)  args ...type，自动生成切片数组，语法糖
> + 参数传递有两种，全部【args...】，部分【args[1:]...】，
> + 任意类型的不定参数， args ...interface{}
+ 4.4 多返回值
> 解决了需要构造结构体来接收多返回值的困扰
> 返回暂时用不到的值可以用 下划线_ 来接收
+ 4.5 匿名函数和闭包
> + 匿名函数
> 匿名与函数的使用区别是，不用写函数名，可以直接用变量接收函数返回返回值
> + 闭包
> Go的匿名函数是一个闭包
> 案例存疑
### 5. 错误处理
+ 5.1 error接口
> 
+ 5.2 defer延迟执行【句柄操作】
> 解决最后统一清理资源的工作
+ 5.3 panic()和recover()
> func panic(interface) 【interface代表接受任意参数】
> func recover() interface {}
